// This client was generated by Platformatic from an OpenAPI specification.

// The base URL for the API. This can be overridden by calling `setBaseUrl`.
let baseUrl = ''
function sanitizeUrl (url) {
  if (url.endsWith('/')) { return url.slice(0, -1) } else { return url }
}
/**  @type {import('./risk-manager-types.d.ts').RiskManager['setBaseUrl']} */
export const setBaseUrl = (newUrl) => { baseUrl = sanitizeUrl(newUrl) }
function headersToJSON (headers) {
  const output = {}
  headers.forEach((value, key) => {
    output[key] = value
  })
  return output
}

async function _getRisks (url, request) {
  const queryParameters = ['limit', 'offset', 'totalCount', 'fields', 'where.branchTaxonomyId.eq', 'where.branchTaxonomyId.neq', 'where.branchTaxonomyId.gt', 'where.branchTaxonomyId.gte', 'where.branchTaxonomyId.lt', 'where.branchTaxonomyId.lte', 'where.branchTaxonomyId.like', 'where.branchTaxonomyId.in', 'where.branchTaxonomyId.nin', 'where.branchTaxonomyId.contains', 'where.branchTaxonomyId.contained', 'where.branchTaxonomyId.overlaps', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.graphql.eq', 'where.graphql.neq', 'where.graphql.gt', 'where.graphql.gte', 'where.graphql.lt', 'where.graphql.lte', 'where.graphql.like', 'where.graphql.in', 'where.graphql.nin', 'where.graphql.contains', 'where.graphql.contained', 'where.graphql.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.mainTaxonomyId.eq', 'where.mainTaxonomyId.neq', 'where.mainTaxonomyId.gt', 'where.mainTaxonomyId.gte', 'where.mainTaxonomyId.lt', 'where.mainTaxonomyId.lte', 'where.mainTaxonomyId.like', 'where.mainTaxonomyId.in', 'where.mainTaxonomyId.nin', 'where.mainTaxonomyId.contains', 'where.mainTaxonomyId.contained', 'where.mainTaxonomyId.overlaps', 'where.openapi.eq', 'where.openapi.neq', 'where.openapi.gt', 'where.openapi.gte', 'where.openapi.lt', 'where.openapi.lte', 'where.openapi.like', 'where.openapi.in', 'where.openapi.nin', 'where.openapi.contains', 'where.openapi.contained', 'where.openapi.overlaps', 'where.risk.eq', 'where.risk.neq', 'where.risk.gt', 'where.risk.gte', 'where.risk.lt', 'where.risk.lte', 'where.risk.like', 'where.risk.in', 'where.risk.nin', 'where.risk.contains', 'where.risk.contained', 'where.risk.overlaps', 'where.or', 'orderby.branchTaxonomyId', 'orderby.createdAt', 'orderby.graphql', 'orderby.id', 'orderby.mainTaxonomyId', 'orderby.openapi', 'orderby.risk']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const response = await fetch(`${url}/risks/?${searchParams.toString()}`)

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./risk-manager-types.d.ts').RiskManager['getRisks']} */
export const getRisks = async (request) => {
  return await _getRisks(baseUrl, request)
}
async function _updateRisks (url, request) {
  const queryParameters = ['fields', 'where.branchTaxonomyId.eq', 'where.branchTaxonomyId.neq', 'where.branchTaxonomyId.gt', 'where.branchTaxonomyId.gte', 'where.branchTaxonomyId.lt', 'where.branchTaxonomyId.lte', 'where.branchTaxonomyId.like', 'where.branchTaxonomyId.in', 'where.branchTaxonomyId.nin', 'where.branchTaxonomyId.contains', 'where.branchTaxonomyId.contained', 'where.branchTaxonomyId.overlaps', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.graphql.eq', 'where.graphql.neq', 'where.graphql.gt', 'where.graphql.gte', 'where.graphql.lt', 'where.graphql.lte', 'where.graphql.like', 'where.graphql.in', 'where.graphql.nin', 'where.graphql.contains', 'where.graphql.contained', 'where.graphql.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.mainTaxonomyId.eq', 'where.mainTaxonomyId.neq', 'where.mainTaxonomyId.gt', 'where.mainTaxonomyId.gte', 'where.mainTaxonomyId.lt', 'where.mainTaxonomyId.lte', 'where.mainTaxonomyId.like', 'where.mainTaxonomyId.in', 'where.mainTaxonomyId.nin', 'where.mainTaxonomyId.contains', 'where.mainTaxonomyId.contained', 'where.mainTaxonomyId.overlaps', 'where.openapi.eq', 'where.openapi.neq', 'where.openapi.gt', 'where.openapi.gte', 'where.openapi.lt', 'where.openapi.lte', 'where.openapi.like', 'where.openapi.in', 'where.openapi.nin', 'where.openapi.contains', 'where.openapi.contained', 'where.openapi.overlaps', 'where.risk.eq', 'where.risk.neq', 'where.risk.gt', 'where.risk.gte', 'where.risk.lt', 'where.risk.lte', 'where.risk.like', 'where.risk.in', 'where.risk.nin', 'where.risk.contains', 'where.risk.contained', 'where.risk.overlaps', 'where.or']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/risks/?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./risk-manager-types.d.ts').RiskManager['updateRisks']} */
export const updateRisks = async (request) => {
  return await _updateRisks(baseUrl, request)
}
async function _getRiskById (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const response = await fetch(`${url}/risks/${request.id}?${searchParams.toString()}`)

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./risk-manager-types.d.ts').RiskManager['getRiskById']} */
export const getRiskById = async (request) => {
  return await _getRiskById(baseUrl, request)
}
async function _postBranchRisk (url, request) {
  const headers = {
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/branch-risk`, {
    method: 'POST',
    body: JSON.stringify(request),
    headers
  })

  const textResponses = [200]
  if (textResponses.includes(response.status)) {
    return {
      statusCode: response.status,
      headers: headersToJSON(response.headers),
      body: await response.text()
    }
  }
  if (response.headers.get('content-type') === 'application/json') {
    return {
      statusCode: response.status,
      headers: headersToJSON(response.headers),
      body: await response.json()
    }
  }
  return {
    statusCode: response.status,
    headers: headersToJSON(response.headers),
    body: await response.text()
  }
}

/**  @type {import('./risk-manager-types.d.ts').RiskManager['postBranchRisk']} */
export const postBranchRisk = async (request) => {
  return await _postBranchRisk(baseUrl, request)
}
export default function build (url) {
  url = sanitizeUrl(url)
  return {
    getRisks: _getRisks.bind(url, ...arguments),
    updateRisks: _updateRisks.bind(url, ...arguments),
    getRiskById: _getRiskById.bind(url, ...arguments),
    postBranchRisk: _postBranchRisk.bind(url, ...arguments)
  }
}
