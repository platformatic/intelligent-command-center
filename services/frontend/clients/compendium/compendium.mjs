// This client was generated by Platformatic from an OpenAPI specification.

// The base URL for the API. This can be overridden by calling `setBaseUrl`.
let baseUrl = ''
// The default headers to send within each request. This can be overridden by calling `setDefaultHeaders`.
let defaultHeaders = {}

function sanitizeUrl (url) {
  if (url.endsWith('/')) { return url.slice(0, -1) } else { return url }
}
/**  @type {import('./compendium-types.d.ts').Compendium['setBaseUrl']} */
export const setBaseUrl = (newUrl) => { baseUrl = sanitizeUrl(newUrl) }

/**  @type {import('./compendium-types.d.ts').Compendium['setDefaultHeaders']} */
export const setDefaultHeaders = (headers) => { defaultHeaders = headers }

function headersToJSON (headers) {
  const output = {}
  headers.forEach((value, key) => {
    output[key] = value
  })
  return output
}

async function _getRepositories (url, request) {
  const queryParameters = ['limit', 'offset', 'totalCount', 'fields', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.name.eq', 'where.name.neq', 'where.name.gt', 'where.name.gte', 'where.name.lt', 'where.name.lte', 'where.name.like', 'where.name.in', 'where.name.nin', 'where.name.contains', 'where.name.contained', 'where.name.overlaps', 'where.url.eq', 'where.url.neq', 'where.url.gt', 'where.url.gte', 'where.url.lt', 'where.url.lte', 'where.url.like', 'where.url.in', 'where.url.nin', 'where.url.contains', 'where.url.contained', 'where.url.overlaps', 'where.or', 'orderby.createdAt', 'orderby.id', 'orderby.name', 'orderby.url']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/repositories/?${searchParams.toString()}`, {
    credentials: 'include',
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compendium-types.d.ts').Compendium['getRepositories']} */
export const getRepositories = async (request) => {
  return await _getRepositories(baseUrl, request)
}
async function _createRepository (url, request) {
  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/repositories/`, {
    method: 'POST',
    body: JSON.stringify(request),
    credentials: 'include',
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compendium-types.d.ts').Compendium['createRepository']} */
export const createRepository = async (request) => {
  return await _createRepository(baseUrl, request)
}
async function _updateRepositories (url, request) {
  const queryParameters = ['fields', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.name.eq', 'where.name.neq', 'where.name.gt', 'where.name.gte', 'where.name.lt', 'where.name.lte', 'where.name.like', 'where.name.in', 'where.name.nin', 'where.name.contains', 'where.name.contained', 'where.name.overlaps', 'where.url.eq', 'where.url.neq', 'where.url.gt', 'where.url.gte', 'where.url.lt', 'where.url.lte', 'where.url.like', 'where.url.in', 'where.url.nin', 'where.url.contains', 'where.url.contained', 'where.url.overlaps', 'where.or']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/repositories/?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    credentials: 'include',
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compendium-types.d.ts').Compendium['updateRepositories']} */
export const updateRepositories = async (request) => {
  return await _updateRepositories(baseUrl, request)
}
async function _getRepositoryById (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/repositories/${request.id}?${searchParams.toString()}`, {
    credentials: 'include',
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compendium-types.d.ts').Compendium['getRepositoryById']} */
export const getRepositoryById = async (request) => {
  return await _getRepositoryById(baseUrl, request)
}
async function _updateRepository (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/repositories/${request.id}?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    credentials: 'include',
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compendium-types.d.ts').Compendium['updateRepository']} */
export const updateRepository = async (request) => {
  return await _updateRepository(baseUrl, request)
}
async function _deleteRepositories (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/repositories/${request.id}?${searchParams.toString()}`, {
    method: 'DELETE',
    body: JSON.stringify(request),
    credentials: 'include',
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compendium-types.d.ts').Compendium['deleteRepositories']} */
export const deleteRepositories = async (request) => {
  return await _deleteRepositories(baseUrl, request)
}
async function _getBranchesForRepository (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/repositories/${request.id}/branches?${searchParams.toString()}`, {
    credentials: 'include',
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compendium-types.d.ts').Compendium['getBranchesForRepository']} */
export const getBranchesForRepository = async (request) => {
  return await _getBranchesForRepository(baseUrl, request)
}
async function _getBranches (url, request) {
  const queryParameters = ['limit', 'offset', 'totalCount', 'fields', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.name.eq', 'where.name.neq', 'where.name.gt', 'where.name.gte', 'where.name.lt', 'where.name.lte', 'where.name.like', 'where.name.in', 'where.name.nin', 'where.name.contains', 'where.name.contained', 'where.name.overlaps', 'where.repositoryId.eq', 'where.repositoryId.neq', 'where.repositoryId.gt', 'where.repositoryId.gte', 'where.repositoryId.lt', 'where.repositoryId.lte', 'where.repositoryId.like', 'where.repositoryId.in', 'where.repositoryId.nin', 'where.repositoryId.contains', 'where.repositoryId.contained', 'where.repositoryId.overlaps', 'where.or', 'orderby.createdAt', 'orderby.id', 'orderby.name', 'orderby.repositoryId']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/branches/?${searchParams.toString()}`, {
    credentials: 'include',
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compendium-types.d.ts').Compendium['getBranches']} */
export const getBranches = async (request) => {
  return await _getBranches(baseUrl, request)
}
async function _createBranch (url, request) {
  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/branches/`, {
    method: 'POST',
    body: JSON.stringify(request),
    credentials: 'include',
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compendium-types.d.ts').Compendium['createBranch']} */
export const createBranch = async (request) => {
  return await _createBranch(baseUrl, request)
}
async function _updateBranches (url, request) {
  const queryParameters = ['fields', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.name.eq', 'where.name.neq', 'where.name.gt', 'where.name.gte', 'where.name.lt', 'where.name.lte', 'where.name.like', 'where.name.in', 'where.name.nin', 'where.name.contains', 'where.name.contained', 'where.name.overlaps', 'where.repositoryId.eq', 'where.repositoryId.neq', 'where.repositoryId.gt', 'where.repositoryId.gte', 'where.repositoryId.lt', 'where.repositoryId.lte', 'where.repositoryId.like', 'where.repositoryId.in', 'where.repositoryId.nin', 'where.repositoryId.contains', 'where.repositoryId.contained', 'where.repositoryId.overlaps', 'where.or']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/branches/?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    credentials: 'include',
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compendium-types.d.ts').Compendium['updateBranches']} */
export const updateBranches = async (request) => {
  return await _updateBranches(baseUrl, request)
}
async function _getBranchById (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/branches/${request.id}?${searchParams.toString()}`, {
    credentials: 'include',
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compendium-types.d.ts').Compendium['getBranchById']} */
export const getBranchById = async (request) => {
  return await _getBranchById(baseUrl, request)
}
async function _updateBranch (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/branches/${request.id}?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    credentials: 'include',
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compendium-types.d.ts').Compendium['updateBranch']} */
export const updateBranch = async (request) => {
  return await _updateBranch(baseUrl, request)
}
async function _deleteBranches (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/branches/${request.id}?${searchParams.toString()}`, {
    method: 'DELETE',
    body: JSON.stringify(request),
    credentials: 'include',
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compendium-types.d.ts').Compendium['deleteBranches']} */
export const deleteBranches = async (request) => {
  return await _deleteBranches(baseUrl, request)
}
async function _getPullRequestsForBranch (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/branches/${request.id}/pullRequests?${searchParams.toString()}`, {
    credentials: 'include',
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compendium-types.d.ts').Compendium['getPullRequestsForBranch']} */
export const getPullRequestsForBranch = async (request) => {
  return await _getPullRequestsForBranch(baseUrl, request)
}
async function _getCommitsForBranch (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/branches/${request.id}/commits?${searchParams.toString()}`, {
    credentials: 'include',
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compendium-types.d.ts').Compendium['getCommitsForBranch']} */
export const getCommitsForBranch = async (request) => {
  return await _getCommitsForBranch(baseUrl, request)
}
async function _getRepositoryForBranch (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/branches/${request.id}/repository?${searchParams.toString()}`, {
    credentials: 'include',
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compendium-types.d.ts').Compendium['getRepositoryForBranch']} */
export const getRepositoryForBranch = async (request) => {
  return await _getRepositoryForBranch(baseUrl, request)
}
async function _getPullRequests (url, request) {
  const queryParameters = ['limit', 'offset', 'totalCount', 'fields', 'where.branchId.eq', 'where.branchId.neq', 'where.branchId.gt', 'where.branchId.gte', 'where.branchId.lt', 'where.branchId.lte', 'where.branchId.like', 'where.branchId.in', 'where.branchId.nin', 'where.branchId.contains', 'where.branchId.contained', 'where.branchId.overlaps', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.number.eq', 'where.number.neq', 'where.number.gt', 'where.number.gte', 'where.number.lt', 'where.number.lte', 'where.number.like', 'where.number.in', 'where.number.nin', 'where.number.contains', 'where.number.contained', 'where.number.overlaps', 'where.title.eq', 'where.title.neq', 'where.title.gt', 'where.title.gte', 'where.title.lt', 'where.title.lte', 'where.title.like', 'where.title.in', 'where.title.nin', 'where.title.contains', 'where.title.contained', 'where.title.overlaps', 'where.or', 'orderby.branchId', 'orderby.createdAt', 'orderby.id', 'orderby.number', 'orderby.title']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/pullRequests/?${searchParams.toString()}`, {
    credentials: 'include',
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compendium-types.d.ts').Compendium['getPullRequests']} */
export const getPullRequests = async (request) => {
  return await _getPullRequests(baseUrl, request)
}
async function _createPullRequest (url, request) {
  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/pullRequests/`, {
    method: 'POST',
    body: JSON.stringify(request),
    credentials: 'include',
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compendium-types.d.ts').Compendium['createPullRequest']} */
export const createPullRequest = async (request) => {
  return await _createPullRequest(baseUrl, request)
}
async function _updatePullRequests (url, request) {
  const queryParameters = ['fields', 'where.branchId.eq', 'where.branchId.neq', 'where.branchId.gt', 'where.branchId.gte', 'where.branchId.lt', 'where.branchId.lte', 'where.branchId.like', 'where.branchId.in', 'where.branchId.nin', 'where.branchId.contains', 'where.branchId.contained', 'where.branchId.overlaps', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.number.eq', 'where.number.neq', 'where.number.gt', 'where.number.gte', 'where.number.lt', 'where.number.lte', 'where.number.like', 'where.number.in', 'where.number.nin', 'where.number.contains', 'where.number.contained', 'where.number.overlaps', 'where.title.eq', 'where.title.neq', 'where.title.gt', 'where.title.gte', 'where.title.lt', 'where.title.lte', 'where.title.like', 'where.title.in', 'where.title.nin', 'where.title.contains', 'where.title.contained', 'where.title.overlaps', 'where.or']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/pullRequests/?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    credentials: 'include',
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compendium-types.d.ts').Compendium['updatePullRequests']} */
export const updatePullRequests = async (request) => {
  return await _updatePullRequests(baseUrl, request)
}
async function _getPullRequestById (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/pullRequests/${request.id}?${searchParams.toString()}`, {
    credentials: 'include',
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compendium-types.d.ts').Compendium['getPullRequestById']} */
export const getPullRequestById = async (request) => {
  return await _getPullRequestById(baseUrl, request)
}
async function _updatePullRequest (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/pullRequests/${request.id}?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    credentials: 'include',
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compendium-types.d.ts').Compendium['updatePullRequest']} */
export const updatePullRequest = async (request) => {
  return await _updatePullRequest(baseUrl, request)
}
async function _deletePullRequests (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/pullRequests/${request.id}?${searchParams.toString()}`, {
    method: 'DELETE',
    body: JSON.stringify(request),
    credentials: 'include',
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compendium-types.d.ts').Compendium['deletePullRequests']} */
export const deletePullRequests = async (request) => {
  return await _deletePullRequests(baseUrl, request)
}
async function _getBranchForPullRequest (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/pullRequests/${request.id}/branch?${searchParams.toString()}`, {
    credentials: 'include',
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compendium-types.d.ts').Compendium['getBranchForPullRequest']} */
export const getBranchForPullRequest = async (request) => {
  return await _getBranchForPullRequest(baseUrl, request)
}
async function _getBundles (url, request) {
  const queryParameters = ['limit', 'offset', 'totalCount', 'fields', 'where.applicationId.eq', 'where.applicationId.neq', 'where.applicationId.gt', 'where.applicationId.gte', 'where.applicationId.lt', 'where.applicationId.lte', 'where.applicationId.like', 'where.applicationId.in', 'where.applicationId.nin', 'where.applicationId.contains', 'where.applicationId.contained', 'where.applicationId.overlaps', 'where.codeChecksum.eq', 'where.codeChecksum.neq', 'where.codeChecksum.gt', 'where.codeChecksum.gte', 'where.codeChecksum.lt', 'where.codeChecksum.lte', 'where.codeChecksum.like', 'where.codeChecksum.in', 'where.codeChecksum.nin', 'where.codeChecksum.contains', 'where.codeChecksum.contained', 'where.codeChecksum.overlaps', 'where.commitId.eq', 'where.commitId.neq', 'where.commitId.gt', 'where.commitId.gte', 'where.commitId.lt', 'where.commitId.lte', 'where.commitId.like', 'where.commitId.in', 'where.commitId.nin', 'where.commitId.contains', 'where.commitId.contained', 'where.commitId.overlaps', 'where.configPath.eq', 'where.configPath.neq', 'where.configPath.gt', 'where.configPath.gte', 'where.configPath.lt', 'where.configPath.lte', 'where.configPath.like', 'where.configPath.in', 'where.configPath.nin', 'where.configPath.contains', 'where.configPath.contained', 'where.configPath.overlaps', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.size.eq', 'where.size.neq', 'where.size.gt', 'where.size.gte', 'where.size.lt', 'where.size.lte', 'where.size.like', 'where.size.in', 'where.size.nin', 'where.size.contains', 'where.size.contained', 'where.size.overlaps', 'where.uploadKey.eq', 'where.uploadKey.neq', 'where.uploadKey.gt', 'where.uploadKey.gte', 'where.uploadKey.lt', 'where.uploadKey.lte', 'where.uploadKey.like', 'where.uploadKey.in', 'where.uploadKey.nin', 'where.uploadKey.contains', 'where.uploadKey.contained', 'where.uploadKey.overlaps', 'where.or', 'orderby.applicationId', 'orderby.codeChecksum', 'orderby.commitId', 'orderby.configPath', 'orderby.createdAt', 'orderby.id', 'orderby.size', 'orderby.uploadKey']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/bundles/?${searchParams.toString()}`, {
    credentials: 'include',
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compendium-types.d.ts').Compendium['getBundles']} */
export const getBundles = async (request) => {
  return await _getBundles(baseUrl, request)
}
async function _createBundle (url, request) {
  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/bundles/`, {
    method: 'POST',
    body: JSON.stringify(request),
    credentials: 'include',
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compendium-types.d.ts').Compendium['createBundle']} */
export const createBundle = async (request) => {
  return await _createBundle(baseUrl, request)
}
async function _updateBundles (url, request) {
  const queryParameters = ['fields', 'where.applicationId.eq', 'where.applicationId.neq', 'where.applicationId.gt', 'where.applicationId.gte', 'where.applicationId.lt', 'where.applicationId.lte', 'where.applicationId.like', 'where.applicationId.in', 'where.applicationId.nin', 'where.applicationId.contains', 'where.applicationId.contained', 'where.applicationId.overlaps', 'where.codeChecksum.eq', 'where.codeChecksum.neq', 'where.codeChecksum.gt', 'where.codeChecksum.gte', 'where.codeChecksum.lt', 'where.codeChecksum.lte', 'where.codeChecksum.like', 'where.codeChecksum.in', 'where.codeChecksum.nin', 'where.codeChecksum.contains', 'where.codeChecksum.contained', 'where.codeChecksum.overlaps', 'where.commitId.eq', 'where.commitId.neq', 'where.commitId.gt', 'where.commitId.gte', 'where.commitId.lt', 'where.commitId.lte', 'where.commitId.like', 'where.commitId.in', 'where.commitId.nin', 'where.commitId.contains', 'where.commitId.contained', 'where.commitId.overlaps', 'where.configPath.eq', 'where.configPath.neq', 'where.configPath.gt', 'where.configPath.gte', 'where.configPath.lt', 'where.configPath.lte', 'where.configPath.like', 'where.configPath.in', 'where.configPath.nin', 'where.configPath.contains', 'where.configPath.contained', 'where.configPath.overlaps', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.size.eq', 'where.size.neq', 'where.size.gt', 'where.size.gte', 'where.size.lt', 'where.size.lte', 'where.size.like', 'where.size.in', 'where.size.nin', 'where.size.contains', 'where.size.contained', 'where.size.overlaps', 'where.uploadKey.eq', 'where.uploadKey.neq', 'where.uploadKey.gt', 'where.uploadKey.gte', 'where.uploadKey.lt', 'where.uploadKey.lte', 'where.uploadKey.like', 'where.uploadKey.in', 'where.uploadKey.nin', 'where.uploadKey.contains', 'where.uploadKey.contained', 'where.uploadKey.overlaps', 'where.or']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/bundles/?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    credentials: 'include',
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compendium-types.d.ts').Compendium['updateBundles']} */
export const updateBundles = async (request) => {
  return await _updateBundles(baseUrl, request)
}
async function _getBundleById (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/bundles/${request.id}?${searchParams.toString()}`, {
    credentials: 'include',
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compendium-types.d.ts').Compendium['getBundleById']} */
export const getBundleById = async (request) => {
  return await _getBundleById(baseUrl, request)
}
async function _updateBundle (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/bundles/${request.id}?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    credentials: 'include',
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compendium-types.d.ts').Compendium['updateBundle']} */
export const updateBundle = async (request) => {
  return await _updateBundle(baseUrl, request)
}
async function _deleteBundles (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/bundles/${request.id}?${searchParams.toString()}`, {
    method: 'DELETE',
    body: JSON.stringify(request),
    credentials: 'include',
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compendium-types.d.ts').Compendium['deleteBundles']} */
export const deleteBundles = async (request) => {
  return await _deleteBundles(baseUrl, request)
}
async function _getCommitForBundle (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/bundles/${request.id}/commit?${searchParams.toString()}`, {
    credentials: 'include',
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compendium-types.d.ts').Compendium['getCommitForBundle']} */
export const getCommitForBundle = async (request) => {
  return await _getCommitForBundle(baseUrl, request)
}
async function _getExportables (url, request) {
  const queryParameters = ['limit', 'offset', 'totalCount', 'fields', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.generationId.eq', 'where.generationId.neq', 'where.generationId.gt', 'where.generationId.gte', 'where.generationId.lt', 'where.generationId.lte', 'where.generationId.like', 'where.generationId.in', 'where.generationId.nin', 'where.generationId.contains', 'where.generationId.contained', 'where.generationId.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.taxonomyId.eq', 'where.taxonomyId.neq', 'where.taxonomyId.gt', 'where.taxonomyId.gte', 'where.taxonomyId.lt', 'where.taxonomyId.lte', 'where.taxonomyId.like', 'where.taxonomyId.in', 'where.taxonomyId.nin', 'where.taxonomyId.contains', 'where.taxonomyId.contained', 'where.taxonomyId.overlaps', 'where.uploadKey.eq', 'where.uploadKey.neq', 'where.uploadKey.gt', 'where.uploadKey.gte', 'where.uploadKey.lt', 'where.uploadKey.lte', 'where.uploadKey.like', 'where.uploadKey.in', 'where.uploadKey.nin', 'where.uploadKey.contains', 'where.uploadKey.contained', 'where.uploadKey.overlaps', 'where.or', 'orderby.createdAt', 'orderby.generationId', 'orderby.id', 'orderby.taxonomyId', 'orderby.uploadKey']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/exportables/?${searchParams.toString()}`, {
    credentials: 'include',
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compendium-types.d.ts').Compendium['getExportables']} */
export const getExportables = async (request) => {
  return await _getExportables(baseUrl, request)
}
async function _createExportable (url, request) {
  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/exportables/`, {
    method: 'POST',
    body: JSON.stringify(request),
    credentials: 'include',
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compendium-types.d.ts').Compendium['createExportable']} */
export const createExportable = async (request) => {
  return await _createExportable(baseUrl, request)
}
async function _updateExportables (url, request) {
  const queryParameters = ['fields', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.generationId.eq', 'where.generationId.neq', 'where.generationId.gt', 'where.generationId.gte', 'where.generationId.lt', 'where.generationId.lte', 'where.generationId.like', 'where.generationId.in', 'where.generationId.nin', 'where.generationId.contains', 'where.generationId.contained', 'where.generationId.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.taxonomyId.eq', 'where.taxonomyId.neq', 'where.taxonomyId.gt', 'where.taxonomyId.gte', 'where.taxonomyId.lt', 'where.taxonomyId.lte', 'where.taxonomyId.like', 'where.taxonomyId.in', 'where.taxonomyId.nin', 'where.taxonomyId.contains', 'where.taxonomyId.contained', 'where.taxonomyId.overlaps', 'where.uploadKey.eq', 'where.uploadKey.neq', 'where.uploadKey.gt', 'where.uploadKey.gte', 'where.uploadKey.lt', 'where.uploadKey.lte', 'where.uploadKey.like', 'where.uploadKey.in', 'where.uploadKey.nin', 'where.uploadKey.contains', 'where.uploadKey.contained', 'where.uploadKey.overlaps', 'where.or']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/exportables/?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    credentials: 'include',
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compendium-types.d.ts').Compendium['updateExportables']} */
export const updateExportables = async (request) => {
  return await _updateExportables(baseUrl, request)
}
async function _getExportableById (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/exportables/${request.id}?${searchParams.toString()}`, {
    credentials: 'include',
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compendium-types.d.ts').Compendium['getExportableById']} */
export const getExportableById = async (request) => {
  return await _getExportableById(baseUrl, request)
}
async function _updateExportable (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/exportables/${request.id}?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    credentials: 'include',
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compendium-types.d.ts').Compendium['updateExportable']} */
export const updateExportable = async (request) => {
  return await _updateExportable(baseUrl, request)
}
async function _deleteExportables (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/exportables/${request.id}?${searchParams.toString()}`, {
    method: 'DELETE',
    body: JSON.stringify(request),
    credentials: 'include',
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compendium-types.d.ts').Compendium['deleteExportables']} */
export const deleteExportables = async (request) => {
  return await _deleteExportables(baseUrl, request)
}
async function _getCommits (url, request) {
  const queryParameters = ['limit', 'offset', 'totalCount', 'fields', 'where.branchId.eq', 'where.branchId.neq', 'where.branchId.gt', 'where.branchId.gte', 'where.branchId.lt', 'where.branchId.lte', 'where.branchId.like', 'where.branchId.in', 'where.branchId.nin', 'where.branchId.contains', 'where.branchId.contained', 'where.branchId.overlaps', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.message.eq', 'where.message.neq', 'where.message.gt', 'where.message.gte', 'where.message.lt', 'where.message.lte', 'where.message.like', 'where.message.in', 'where.message.nin', 'where.message.contains', 'where.message.contained', 'where.message.overlaps', 'where.sha.eq', 'where.sha.neq', 'where.sha.gt', 'where.sha.gte', 'where.sha.lt', 'where.sha.lte', 'where.sha.like', 'where.sha.in', 'where.sha.nin', 'where.sha.contains', 'where.sha.contained', 'where.sha.overlaps', 'where.userEmail.eq', 'where.userEmail.neq', 'where.userEmail.gt', 'where.userEmail.gte', 'where.userEmail.lt', 'where.userEmail.lte', 'where.userEmail.like', 'where.userEmail.in', 'where.userEmail.nin', 'where.userEmail.contains', 'where.userEmail.contained', 'where.userEmail.overlaps', 'where.or', 'orderby.branchId', 'orderby.createdAt', 'orderby.id', 'orderby.message', 'orderby.sha', 'orderby.userEmail']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/commits/?${searchParams.toString()}`, {
    credentials: 'include',
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compendium-types.d.ts').Compendium['getCommits']} */
export const getCommits = async (request) => {
  return await _getCommits(baseUrl, request)
}
async function _createCommit (url, request) {
  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/commits/`, {
    method: 'POST',
    body: JSON.stringify(request),
    credentials: 'include',
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compendium-types.d.ts').Compendium['createCommit']} */
export const createCommit = async (request) => {
  return await _createCommit(baseUrl, request)
}
async function _updateCommits (url, request) {
  const queryParameters = ['fields', 'where.branchId.eq', 'where.branchId.neq', 'where.branchId.gt', 'where.branchId.gte', 'where.branchId.lt', 'where.branchId.lte', 'where.branchId.like', 'where.branchId.in', 'where.branchId.nin', 'where.branchId.contains', 'where.branchId.contained', 'where.branchId.overlaps', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.message.eq', 'where.message.neq', 'where.message.gt', 'where.message.gte', 'where.message.lt', 'where.message.lte', 'where.message.like', 'where.message.in', 'where.message.nin', 'where.message.contains', 'where.message.contained', 'where.message.overlaps', 'where.sha.eq', 'where.sha.neq', 'where.sha.gt', 'where.sha.gte', 'where.sha.lt', 'where.sha.lte', 'where.sha.like', 'where.sha.in', 'where.sha.nin', 'where.sha.contains', 'where.sha.contained', 'where.sha.overlaps', 'where.userEmail.eq', 'where.userEmail.neq', 'where.userEmail.gt', 'where.userEmail.gte', 'where.userEmail.lt', 'where.userEmail.lte', 'where.userEmail.like', 'where.userEmail.in', 'where.userEmail.nin', 'where.userEmail.contains', 'where.userEmail.contained', 'where.userEmail.overlaps', 'where.or']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/commits/?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    credentials: 'include',
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compendium-types.d.ts').Compendium['updateCommits']} */
export const updateCommits = async (request) => {
  return await _updateCommits(baseUrl, request)
}
async function _getCommitById (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/commits/${request.id}?${searchParams.toString()}`, {
    credentials: 'include',
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compendium-types.d.ts').Compendium['getCommitById']} */
export const getCommitById = async (request) => {
  return await _getCommitById(baseUrl, request)
}
async function _updateCommit (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/commits/${request.id}?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    credentials: 'include',
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compendium-types.d.ts').Compendium['updateCommit']} */
export const updateCommit = async (request) => {
  return await _updateCommit(baseUrl, request)
}
async function _deleteCommits (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/commits/${request.id}?${searchParams.toString()}`, {
    method: 'DELETE',
    body: JSON.stringify(request),
    credentials: 'include',
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compendium-types.d.ts').Compendium['deleteCommits']} */
export const deleteCommits = async (request) => {
  return await _deleteCommits(baseUrl, request)
}
async function _getBundlesForCommit (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/commits/${request.id}/bundles?${searchParams.toString()}`, {
    credentials: 'include',
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compendium-types.d.ts').Compendium['getBundlesForCommit']} */
export const getBundlesForCommit = async (request) => {
  return await _getBundlesForCommit(baseUrl, request)
}
async function _getBranchForCommit (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/commits/${request.id}/branch?${searchParams.toString()}`, {
    credentials: 'include',
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compendium-types.d.ts').Compendium['getBranchForCommit']} */
export const getBranchForCommit = async (request) => {
  return await _getBranchForCommit(baseUrl, request)
}
async function _getBundlesWithMetadata (url, request) {
  const queryParameters = ['bundleIds', 'applicationIds', 'limit', 'offset']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/bundles-with-metadata?${searchParams.toString()}`, {
    credentials: 'include',
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compendium-types.d.ts').Compendium['getBundlesWithMetadata']} */
export const getBundlesWithMetadata = async (request) => {
  return await _getBundlesWithMetadata(baseUrl, request)
}
async function _deployBundle (url, request) {
  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/bundles/deploy`, {
    method: 'POST',
    body: JSON.stringify(request),
    credentials: 'include',
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compendium-types.d.ts').Compendium['deployBundle']} */
export const deployBundle = async (request) => {
  return await _deployBundle(baseUrl, request)
}
async function _uploadBundle (url, request) {
  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }
  if (request['x-platformatic-deploy-token'] !== undefined) {
    headers['x-platformatic-deploy-token'] = request['x-platformatic-deploy-token']
    delete request['x-platformatic-deploy-token']
  }

  const response = await fetch(`${url}/bundles/${request.id}/upload`, {
    method: 'PUT',
    body: JSON.stringify(request),
    credentials: 'include',
    headers
  })

  const textResponses = [200]
  if (textResponses.includes(response.status)) {
    return {
      statusCode: response.status,
      headers: headersToJSON(response.headers),
      body: await response.text()
    }
  }
  if (response.headers.get('content-type').startsWith('application/json')) {
    return {
      statusCode: response.status,
      headers: headersToJSON(response.headers),
      body: await response.json()
    }
  }
  return {
    statusCode: response.status,
    headers: headersToJSON(response.headers),
    body: await response.text()
  }
}

/**  @type {import('./compendium-types.d.ts').Compendium['uploadBundle']} */
export const uploadBundle = async (request) => {
  return await _uploadBundle(baseUrl, request)
}
async function _getBundleDownloadUrl (url, request) {
  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/bundles/${request.id}/download-url`, {
    method: 'POST',
    body: JSON.stringify(request),
    credentials: 'include',
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compendium-types.d.ts').Compendium['getBundleDownloadUrl']} */
export const getBundleDownloadUrl = async (request) => {
  return await _getBundleDownloadUrl(baseUrl, request)
}
async function _getExportableDownloadUrl (url, request) {
  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/exportables/${request.id}/download-url`, {
    method: 'POST',
    body: JSON.stringify(request),
    credentials: 'include',
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compendium-types.d.ts').Compendium['getExportableDownloadUrl']} */
export const getExportableDownloadUrl = async (request) => {
  return await _getExportableDownloadUrl(baseUrl, request)
}
async function _deployExportable (url, request) {
  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/exportables/deploy`, {
    method: 'POST',
    body: JSON.stringify(request),
    credentials: 'include',
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./compendium-types.d.ts').Compendium['deployExportable']} */
export const deployExportable = async (request) => {
  return await _deployExportable(baseUrl, request)
}
async function _uploadExportable (url, request) {
  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/exportables/${request.id}/upload`, {
    method: 'PUT',
    body: JSON.stringify(request),
    credentials: 'include',
    headers
  })

  const textResponses = [200]
  if (textResponses.includes(response.status)) {
    return {
      statusCode: response.status,
      headers: headersToJSON(response.headers),
      body: await response.text()
    }
  }
  if (response.headers.get('content-type').startsWith('application/json')) {
    return {
      statusCode: response.status,
      headers: headersToJSON(response.headers),
      body: await response.json()
    }
  }
  return {
    statusCode: response.status,
    headers: headersToJSON(response.headers),
    body: await response.text()
  }
}

/**  @type {import('./compendium-types.d.ts').Compendium['uploadExportable']} */
export const uploadExportable = async (request) => {
  return await _uploadExportable(baseUrl, request)
}
export default function build (url, options) {
  url = sanitizeUrl(url)
  if (options?.headers) {
    defaultHeaders = options.headers
  }
  return {
    getRepositories: _getRepositories.bind(url, ...arguments),
    createRepository: _createRepository.bind(url, ...arguments),
    updateRepositories: _updateRepositories.bind(url, ...arguments),
    getRepositoryById: _getRepositoryById.bind(url, ...arguments),
    updateRepository: _updateRepository.bind(url, ...arguments),
    deleteRepositories: _deleteRepositories.bind(url, ...arguments),
    getBranchesForRepository: _getBranchesForRepository.bind(url, ...arguments),
    getBranches: _getBranches.bind(url, ...arguments),
    createBranch: _createBranch.bind(url, ...arguments),
    updateBranches: _updateBranches.bind(url, ...arguments),
    getBranchById: _getBranchById.bind(url, ...arguments),
    updateBranch: _updateBranch.bind(url, ...arguments),
    deleteBranches: _deleteBranches.bind(url, ...arguments),
    getPullRequestsForBranch: _getPullRequestsForBranch.bind(url, ...arguments),
    getCommitsForBranch: _getCommitsForBranch.bind(url, ...arguments),
    getRepositoryForBranch: _getRepositoryForBranch.bind(url, ...arguments),
    getPullRequests: _getPullRequests.bind(url, ...arguments),
    createPullRequest: _createPullRequest.bind(url, ...arguments),
    updatePullRequests: _updatePullRequests.bind(url, ...arguments),
    getPullRequestById: _getPullRequestById.bind(url, ...arguments),
    updatePullRequest: _updatePullRequest.bind(url, ...arguments),
    deletePullRequests: _deletePullRequests.bind(url, ...arguments),
    getBranchForPullRequest: _getBranchForPullRequest.bind(url, ...arguments),
    getBundles: _getBundles.bind(url, ...arguments),
    createBundle: _createBundle.bind(url, ...arguments),
    updateBundles: _updateBundles.bind(url, ...arguments),
    getBundleById: _getBundleById.bind(url, ...arguments),
    updateBundle: _updateBundle.bind(url, ...arguments),
    deleteBundles: _deleteBundles.bind(url, ...arguments),
    getCommitForBundle: _getCommitForBundle.bind(url, ...arguments),
    getExportables: _getExportables.bind(url, ...arguments),
    createExportable: _createExportable.bind(url, ...arguments),
    updateExportables: _updateExportables.bind(url, ...arguments),
    getExportableById: _getExportableById.bind(url, ...arguments),
    updateExportable: _updateExportable.bind(url, ...arguments),
    deleteExportables: _deleteExportables.bind(url, ...arguments),
    getCommits: _getCommits.bind(url, ...arguments),
    createCommit: _createCommit.bind(url, ...arguments),
    updateCommits: _updateCommits.bind(url, ...arguments),
    getCommitById: _getCommitById.bind(url, ...arguments),
    updateCommit: _updateCommit.bind(url, ...arguments),
    deleteCommits: _deleteCommits.bind(url, ...arguments),
    getBundlesForCommit: _getBundlesForCommit.bind(url, ...arguments),
    getBranchForCommit: _getBranchForCommit.bind(url, ...arguments),
    getBundlesWithMetadata: _getBundlesWithMetadata.bind(url, ...arguments),
    deployBundle: _deployBundle.bind(url, ...arguments),
    uploadBundle: _uploadBundle.bind(url, ...arguments),
    getBundleDownloadUrl: _getBundleDownloadUrl.bind(url, ...arguments),
    getExportableDownloadUrl: _getExportableDownloadUrl.bind(url, ...arguments),
    deployExportable: _deployExportable.bind(url, ...arguments),
    uploadExportable: _uploadExportable.bind(url, ...arguments)
  }
}
